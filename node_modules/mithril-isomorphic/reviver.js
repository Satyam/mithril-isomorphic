/* jshint browser:true, devel:true */
/* global Mithril */



// I need to collect the calls to withAttr to pick the arguments passed
// and the wrapped function so that I can revive those calls in the existing DOM
Mithril.$wAttrList = [];
Mithril.withAttr = (function (original) {
	return function () {
		var result = original.apply(this, arguments);
		Mithril.$wAttrList.push({
			attr: arguments[0],
			fn: arguments[1],
			wrap: result
		});
		return result;
	};

})(Mithril.withAttr);

/* The $reviver function reads the processed view in `cell` that would normally
	be used to produce the HTML and matches it with the HTML sent from 
	the server starting in root.   
	The combination of the two is stored in `cellCache`.   
	In order to revive the functions, the controller that this view belongs to
	is also needed.
*/
Mithril.$reviver = function (cellCache, root, cell, controller) {

	// Skips over pure whitespace nodes.  
	// I am not sure which browsers  support nextElementSibling so I do it in code.
	var nextEl = function (node) {
		if (node === null) return null;
		while (node.nodeName == "#text" && node.nodeValue.trim().length === 0) node = node.nextSibling;
		return node;
	};
	
	// Checks if the function `fn` is a method within the controller.
	// Returns the name of the method.
	var inController = function (fn) {
		for (var m in controller) {
			if (controller[m] == fn) {
				return m;
			}
		}
	};
	
	// Revives the function `fn` that was set in the attribute `attr`
	// and attaches it to `node`
	var reviveFn = function (node, attrName, fn) {
		var m; //, obj;

		// This part is mostly copied over from Mithril: 
		// I am not sure why it uses add and remove when
		// for other events it just sets the `onxxxx` attribute.
		if (attrName == 'config' && fn == Mithril.route) {
			node.removeEventListener("click", Mithril.$routeUnobtrusive);
			node.addEventListener("click", Mithril.$routeUnobtrusive);
			return;
		}
		
		// Check for references to methods in the controller
		m = inController(fn);
		if (m) {
			node[attrName] = Mithril.$autoRedraw(controller[m]);
			return;
		}

		// Check for calls to `m.withAttr()`
		for (m = 0; m < Mithril.$wAttrList.length; m++) {
			var entry = Mithril.$wAttrList[m];
			if (entry.wrap == fn) {
				// I assume the method is part of the controller.
				// It might not always be true.
				// I should cover other possibilities
				m = inController(entry.fn);
				node[attrName] = Mithril.$autoRedraw(Mithril.withAttr(entry.attr, controller[m]));
				return; 
			}
		}

		// Check for other calls to Mithril methods
		for (m in Mithril) {
			if (Mithril[m] == fn) {
				node[attrName] = Mithril.$autoRedraw(fn);
				return;
			}
		}
		// Didn't match anything, it is probably an inline, anonymous function
		// just let it pass through.
		
		// Important:  it is not being wrapped in autoredraw
		// In the demo it works because it is the change in the tab that
		// forces the redraw and gets the quotes changed.
		return fn.toString();
	};

	// Revives a single level of nodes in the hierarchy.
	// It is called recursively for each level down.
	// The `cell` argument is the processed node as returned by the view.
	// `parentNode` is an actual DOM node.
	var revive = function (cell, parentNode) {
		var i, cache, node = parentNode && nextEl(parentNode.firstChild);
		
		// If the cell contains nothing but a string, 
		// return it with a reference to the matching node
		if (typeof cell == 'string') {
			cell = new ''.constructor(cell);
			cell.nodes = [node];
			return cell;
		}
		
		// copies the attributes from a single `cell` as 
		// would have been produced by a call to `m()`
		// and returns the corresponding level to be 
		// stored in `cellCache`
		
		// It is mostly a matter of associating the actual DOM
		// node as produced from the HTML sent from the server
		// and reviving the functions associated to events.
		var copy = function (cell) {
			var prop, value, attrs = {}, attrN, attrV, ret = {};
			
			if (typeof cell == 'string') {
				ret = new ''.constructor(cell);
			} else {
				for (prop in cell) {
					value = cell[prop];
					switch (prop) {
					case 'children':
						// Recursively revive each level
						if (value) ret.children = revive(value, node);
						break;
					case 'attrs':
						for (attrN in value) {
							attrV = value[attrN];
							// If any of the attributes is a function, revive it.
							if (typeof attrV == 'function') {
								attrV = reviveFn(node, attrN, attrV);
							}
							attrs[attrN] = attrV;
						}
						ret.attrs = attrs;
						break;
					default:
						ret[prop] = value;
					}
				}
			}
			// Associate the DOM node
			ret.nodes = [node];
			// move to the next node
			node = node && nextEl(node.nextSibling);
			// returned the representation of this branch
			return ret;
		};
		
		// handle either an array of cells or a single cell
		if (Array.isArray(cell)) {
			cache = cell.map(copy);
			// If it didn't get DOM nodes associated with it 
			// (which normally would not)
			// collect the nodes associated with its children
			// which should
			if (!cache.nodes) {
				cache.nodes = cache.map(function (cell) {
					return cell.nodes[0];
				});
			}
		} else {
			cache = copy(cell);
		}
		return cache;
	};
	var c = revive(cell, root);
	cellCache[0] = c;
//	console.log('\n\nvar cellCacheR = ', JSON.stringify(c, function (key, value) {
//		if (key == 'nodes') value = value.length + ' [' + value.map(function (node) {
//			return (node ? node.nodeName || node.nodeValue : 'null*node');
//		}) + ']';
//		return value;
//	}));
};