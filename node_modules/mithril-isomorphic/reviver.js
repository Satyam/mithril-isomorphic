/* jshint browser:true, devel:true */
/* global Mithril */



/* The $reviver function reads the processed view in `cell` that would normally
	be used to produce the HTML and matches it with the HTML sent from 
	the server starting in root.   
	The combination of the two is stored in `cellCache`.   
	In order to revive the functions, the controller that this view belongs to
	is also needed.
*/
Mithril.$reviver = function (cellCache, root, cell, controller) {

	// Skips over pure whitespace nodes.  
	// I am not sure which browsers  support nextElementSibling so I do it in code.
	var nextEl = function (node) {
		if (node === null) return null;
		while (node.nodeName == "#text" && node.nodeValue.trim().length === 0) node = node.nextSibling;
		return node;
	};
	

	
	// Revives the function `fn` that was set in the attribute `attr`
	// and attaches it to `node`
	var reviveFn = function (node, attrName, fn) {

		// Take care to properly redirect calls to m.route
		if (attrName == 'config' && fn == Mithril.route) {
			node.onclick = Mithril.$routeUnobtrusive;
			return;
		}
		
		// All the rest of the functions just need to be wrapped 
		// by `autoredraw` so as to notfy Mithril that a refresh is in order
		node[attrName] = Mithril.$autoRedraw(fn);
		
		
	};

	// Revives a single level of nodes in the hierarchy.
	// It is called recursively for each level down.
	// The `cell` argument is the processed node as returned by the view.
	// `parentNode` is an actual DOM node.
	var revive = function (cell, parentNode) {
		var i, cache, node = parentNode && nextEl(parentNode.firstChild);
		
		// If the cell contains nothing but a string, 
		// return it with a reference to the matching node
		if (typeof cell == 'string') {
			cell = new ''.constructor(cell);
			cell.nodes = [node];
			return cell;
		}
		
		// copies the attributes from a single `cell` as 
		// would have been produced by a call to `m()`
		// and returns the corresponding level to be 
		// stored in `cellCache`
		
		// It is mostly a matter of associating the actual DOM
		// node as produced from the HTML sent from the server
		// and reviving the functions associated to events.
		var copy = function (cell) {
			var prop, value, attrs = {}, attrN, attrV, ret = {};
			
			if (typeof cell == 'string') {
				ret = new ''.constructor(cell);
			} else {
				for (prop in cell) {
					value = cell[prop];
					switch (prop) {
					case 'children':
						// Recursively revive each level
						if (value) ret.children = revive(value, node);
						break;
					case 'attrs':
						for (attrN in value) {
							attrV = value[attrN];
							// If any of the attributes is a function, revive it.
							if (typeof attrV == 'function') {
								attrV = reviveFn(node, attrN, attrV);
							}
							attrs[attrN] = attrV;
						}
						ret.attrs = attrs;
						break;
					default:
						ret[prop] = value;
					}
				}
			}
			// Associate the DOM node
			ret.nodes = [node];
			// move to the next node
			node = node && nextEl(node.nextSibling);
			// returned the representation of this branch
			return ret;
		};
		
		// handle either an array of cells or a single cell
		if (Array.isArray(cell)) {
			cache = cell.map(copy);
			// If it didn't get DOM nodes associated with it 
			// (which normally would not)
			// collect the nodes associated with its children
			// which should
			if (!cache.nodes) {
				cache.nodes = cache.map(function (cell) {
					return cell.nodes[0];
				});
			}
		} else {
			cache = copy(cell);
		}
		return cache;
	};
	var c = revive(cell, root);
	cellCache[0] = c;
//	console.log('\n\nvar cellCacheR = ', JSON.stringify(c, function (key, value) {
//		if (key == 'nodes') value = value.length + ' [' + value.map(function (node) {
//			return (node ? node.nodeName || node.nodeValue : 'null*node');
//		}) + ']';
//		return value;
//	}));
};