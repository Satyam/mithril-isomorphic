/* jshint browser:true, devel:true */
/* global Mithril */

Mithril.$wAttrList = [];

Mithril.withAttr = (function (original) {
	return function () {
		console.log('withAttr', arguments[0], arguments[1].toString());
		var result = original.apply(this, arguments);
		Mithril.$wAttrList.push({
			attr: arguments[0],
			fn: arguments[1],
			wrap: result
		});
		return result;
	};

})(Mithril.withAttr);

Mithril.$reviver = function (cellCache, root, cell, controller) {

	var nextEl = function (node) {
		if (node === null) return null;
		while (node.nodeName == "#text" && node.nodeValue.trim().length === 0) node = node.nextSibling;
		return node;
	};
	var inController = function (fn) {
		for (var m in controller) {
			if (controller[m] == fn) {
				return m;
			}
		}
	};
	var reviveFn = function (node, attr, fn) {
		var m; //, obj;

		if (attr == 'config' && fn == Mithril.route) {
			node.removeEventListener("click", Mithril.$routeUnobtrusive);
			node.addEventListener("click", Mithril.$routeUnobtrusive);
			return fn;
		}
		for (m in Mithril) {
			if (Mithril[m] == fn) {
				return '* Mithril: ' + m;
			}
		}

		for (m = 0; m < Mithril.$wAttrList.length; m++) {
			var entry = Mithril.$wAttrList[m];
			if (entry.wrap == fn) {
				m = inController(entry.fn);
				node[attr] = Mithril.$autoRedraw(Mithril.withAttr(entry.attr, controller[m]));
				return; 
			}
		}

		m = inController(fn);
		if (m) {
			node[attr] = Mithril.$autoRedraw(controller[m]);
			return;
		}

		return fn.toString();
	};

	var revive = function (cell, parentNode) {
		var i, cache, node = parentNode && nextEl(parentNode.firstChild);
		if (typeof cell == 'string') {
			cell = new ''.constructor(cell);
			cell.nodes = [node];
			return cell;
		}
		var copy = function (cell) {
			var prop, value, attrs = {}, attrN, attrV, ret = {};
			if (typeof cell == 'string') {
				ret = new ''.constructor(cell);
			} else {
				for (prop in cell) {
					value = cell[prop];
					switch (prop) {
					case 'children':
						if (value) ret.children = revive(value, node);
						break;
					case 'attrs':
						for (attrN in value) {
							attrV = value[attrN];
							if (typeof attrV == 'function') {
								attrV = reviveFn(node, attrN, attrV);
							}
							attrs[attrN] = attrV;
						}
						ret.attrs = attrs;
						break;
					default:
						ret[prop] = value;
					}
				}
			}
			ret.nodes = [node];
			node = node && nextEl(node.nextSibling);
			return ret;
		};
		if (Array.isArray(cell)) {
			cache = cell.map(copy);
			if (!cache.nodes) {
				cache.nodes = cache.map(function (cell) {
					return cell.nodes[0];
				});
			}
		} else {
			cache = copy(cell);
		}
		return cache;
	};
	var c = revive(cell, root);
	cellCache[0] = c;
//	console.log('\n\nvar cellCacheR = ', JSON.stringify(c, function (key, value) {
//		if (key == 'nodes') value = value.length + ' [' + value.map(function (node) {
//			return (node ? node.nodeName || node.nodeValue : 'null*node');
//		}) + ']';
//		return value;
//	}));
};