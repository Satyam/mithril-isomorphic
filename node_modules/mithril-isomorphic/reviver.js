/* jshint browser:true, devel:true */
/* global Mithril */

Mithril.$wAttrList = [];

Mithril.withAttr = (function (original) {
	return function () {
		console.log('withAttr', arguments[0], arguments[1].toString());
		var result = original.apply(this, arguments);
		Mithril.$wAttrList.push({
			attr: arguments[0],
			fn: arguments[1],
			wrap: result
		});
		return result;
	};

})(Mithril.withAttr);

Mithril.$reviver = function (cellCache, root, cell, controller) {

	var nextEl = function (node) {
		if (node === null) return null;
		while (node.nodeName == "#text" && node.nodeValue.trim().length === 0) node = node.nextSibling;
		return node;
	};
	var inController = function (fn) {
		for (var m in controller) {
			if (controller[m] == fn) {
				return m;
			}
		}
	};

	var revive = function (cell, parentNode) {
		var i, cache, node = parentNode && nextEl(parentNode.firstChild);
		var reviveFn = function (attr, fn) {
			var m; //, obj;

			if (attr == 'config' && fn == Mithril.route) {
				node.removeEventListener("click", Mithril.$routeUnobtrusive);
				node.addEventListener("click", Mithril.$routeUnobtrusive);
				return fn;
			}
			for (m in Mithril) {
				if (Mithril[m] == fn) {
					return '* Mithril: ' + m;
				}
			}

			Mithril.$wAttrList.forEach(function (entry) {
				if (entry.wrap == fn) {
					m = inController(entry.fn);
					return '* withAttr ' + entry.attr + (m ? ', controller: ' + m : '');
				}
			});

			//		obj = IsoModules[mod];
			//		for (m in obj) {
			//			if (obj[m] == fn) {
			//				fn = '* IsoModules[' + mod + ']: ' + m;
			//			}
			//		}
			m = inController(fn);
			if (m) return '* controller: ' + m;

			return fn.toString();
		};
		if (typeof cell == 'string') {
			cell = new ''.constructor(cell);
			cell.nodes = [node];
			return cell;
		}
		var copy = function (cell) {
			if (typeof cell == 'string') {
				cell = new ''.constructor(cell);
				cell.nodes = [node];
				return cell;
			}
			var prop, value, attrs = {}, attrN, attrV, ret = {};
			for (prop in cell) {
				value = cell[prop];
				switch (prop) {
				case 'children':
					if (value) ret.children = revive(value, node);
					break;
				case 'attrs':
					for (attrN in value) {
						attrV = value[attrN];
						if (typeof attrV == 'function') {
							attrV = reviveFn(attrN, attrV);
							//							if (attrN == 'config') {
							//								ret.configContext = {};
							//							}
						}
						attrs[attrN] = attrV;
					}
					ret.attrs = attrs;
					break;
				default:
					ret[prop] = value;
				}
			}
			ret.nodes = [node];
			node = node && nextEl(node.nextSibling);
			return ret;
		};
		if (Array.isArray(cell)) {
			cache = cell.map(copy);
			if (!cache.nodes) {
				cache.nodes = cache.map(function (cell) {
					return cell.nodes[0];
				});
			}
		} else {
			cache = copy(cell);
		}
		return cache;
	};
	var c = revive(cell, root);
	cellCache[0] = c;
//	console.log('\n\nvar cellCacheR = ', JSON.stringify(c, function (key, value) {
//		if (key == 'nodes') value = value.length + ' [' + value.map(function (node) {
//			return (node ? node.nodeName || node.nodeValue : 'null*node');
//		}) + ']';
//		return value;
//	}));
};