/* jshint node:true */
'use strict';

var path = require('path'),
	FS = require('q-io/fs'),
	Q = require('q'),
	Mithril = require('mithril'),
	mock = require('./mock.js');

var page,
	routesFname,
	app,
	routes,
	def,
	mod,
	localRoot,
	remoteRoot,
	script,
	placeholder,
	rxApp,
	routeParams = {},
	isoName,
	IsoModules = {},
	modes = {
		pathname: "",
		hash: "#",
		search: "?"
	},
	routeMode;


// Attach the mock DOM to Mithril
Mithril.deps(mock.window);

// Redefine the original `m.route.param`
// to read from my collection of parameters
// collected on the server side.
Mithril.route.param = function (key) {
	console.log('param', key, routeParams[key]);
	return routeParams[key];
};

// Monkey patch the original `m.render` method
// to read the HTML from the mock DOM once it is done rendering.

Mithril.render = (function (original) {

	var logNode = function (node) {
		var prop, val,
			style, styles = [],
			html = '';

		if (!node.nodeName && node.nodeValue !== undefined) {
			// For text nodes, I return the uppercase text
			// so that you can tell the parts generated at the server
			// from the normal lowercase of the actual app when run on the client
			return node.nodeValue.toUpperCase();
		}
		html += '<' + node.nodeName;
		for (prop in node) {
			val = node[prop];

			// Ignore functions, those will be revived on the client side.
			if (typeof val == 'function') continue;
			switch (prop) {
			case 'nodeName':
			case 'parentNode':
			case 'childNodes':
			case 'pathname':
			case 'search':
				continue;
			case 'checked':
				if (val == 'false') continue;
				break;
			case 'href':
				val = node.pathname;
				break;
			case 'className':
				prop = 'class';
				break;
			case 'style':
				if (val) {
					for (style in val) {
						if (val[style]) {
							styles.push(style + ': ' + val[style]);
						}
					}
					if (!styles.length) continue;
					val = styles.join(';');
				}
				break;
			}
			html += ' ' + prop + '="' + val.replace('"', '\\"') + '"';
		}

		if (node.childNodes.length) {
			html += '>' + node.childNodes.reduce(function (prev, node) {
				return prev + logNode(node);
			}, '') + '</' + node.nodeName + '>';
		} else {
			// I don't know why Mithril assigns the content of textareas
			// to its value attribute instead of the innerHTML property.
			// Since it doesn't have children, the closing tag has to be forced.
			if (node.nodeName == 'TEXTAREA') {
				html += '></TEXTAREA>';
			} else {
				html += '/>';
			}
		}
		return html;
	};




	// This is the monkey-patching part:
	return function () {

		var result = original.apply(this, arguments);
		mock.html = mock.window.document.body.childNodes.reduce(function (prev, node) {
			return prev + logNode(node);
		}, '');
		return result;
	};
})(Mithril.render);


//var wAttrList = [];
//Mithril.withAttr = (function (original) {
//	return function () {
//		console.log('withAttr', arguments[0], arguments[1].toString());
//		var result = original.apply(this, arguments);
//		wAttrList.push({
//			attr: arguments[0],
//			fn: arguments[1],
//			wrap: result
//		});
//		return result;
//	};
//
//})(Mithril.withAttr);


module.exports = function (config) {

	config = config || {};
	// Folders
	// Where the application resides
	app = config.app || './app';
	// The root for the static files
	localRoot = config.localRoot || 'client';
	// The root as seen from the far side
	remoteRoot = config.remoteRoot || '/';

	// Files:
	// The home page, located within `localRoot`
	page = config.page || 'index.html';
	// The placeholder for the body within that home page
	placeholder = config.placeholder || '{{body}}';
	// The file name for the routes configuration, located in `app`
	routesFname = config.routes || 'routes.js';
	// The name of the script file where all the application code is collected, located in `app`
	script = config.script || '__.js';

	// The name of the global object where all the modules are collected
	isoName = config.isoName || 'IsoModules';
	// The route mode as per m.routes.mode	
	routeMode = config.routeMode || 'search';

	mock.window.location.pathname = localRoot;
	rxApp = new RegExp(path.join('/', app, '/') + '(.*)');


	// Read the routes file for the modified call to
	// `m.route` or `m.module`

	var r = require(path.resolve(app, routesFname))({
		route: function (d, r) {
			def = d;
			routes = r;
		},
		module: function (m) {
			mod = m;
		}
	});


	// Collect everything that needs to be sent to the client into one script.
	var out = path.resolve(app, script);

	// First, send Mithril itself
	FS.copy(require.resolve('mithril'), out).then(function () {
		// Add the declaration of the variable that will hold the collection of modules:
		return FS.append(out, ';\n' + isoName + ' = {};');
	}).then(function () {
		// Add the reviver
		return FS.read(require.resolve('./reviver.js')).then(function (contents) {
			return FS.append(out, contents);
		});
	}).then(function () {
		// Add all the modules declared
		// skipping over the routes file and the file where the scripts are being collected
		return FS.listTree(app, function (fullPath) {
			return !(
				path.extname(fullPath) != '.js' ||
				path.basename(fullPath) == script ||
				path.basename(fullPath) == routesFname
			);
		}).then(function (files) {
			return Q.all(files.map(function (file) {
				var module = require(path.resolve('./', file));
				module(Mithril, IsoModules);
				return FS.append(out, '\n;(' + module.toString() + ')(Mithril, ' + isoName + ')');
			}));
		});
	}).then(function () {
		// Add either the `m.module` or `m.route` call at the end.
		if (mod) {
			return FS.append(out, '\n;Mithril.module(document.body,' + isoName + '.' + mod + ');');
		}
		if (routes) {
			var rs = [],
				r;
			for (r in routes) {
				rs.push('"' + r + '":' + isoName + '.' + routes[r]);
			}
			return FS.append(out, '\n;Mithril.route(document.body, "' + def + '", {' + rs.join(',') + '});');
		}
	});


	//Entry point to the middleware
	return function (req, res, next) {

		console.log('-----------------------');
		console.log('req.url:', req.url);

		// Skip over the requests I don't need to handle
		var match = rxApp.exec(req.url);
		if (match) {
			if (match[1] == script) {
				console.log('rxmatch == script', match[1]);
				res.sendfile(path.join(app, script));
				return;
			}
			console.log('rxmatch else', match[1]);
			res.send('(' + require(path.resolve(app, match[1])).toString() + ')(Mithril)');
		}

		var accept = req.headers.accept;
		if (
			req.method !== 'GET' ||
			accept.indexOf('application/json') === 0 || !(accept.indexOf('text/html') !== -1 || accept.indexOf('*/*') !== -1)
		) {
			console.log('first ignore');
			return void next();
		}

		if (req.url.indexOf('.') !== -1) {
			console.log('second ignore');
			return void next();
		}

		// This is a copy of the function by the same name
		// in Mithril which is inaccessible from outside.
		var routeByValue = function (router, path) {
			path = path.replace(/^\/\?/, '');
			routeParams = {};
			var replacer = function () {
				var keys = route.match(/:[^\/]+/g);
				var values = [].slice.call(arguments, 1, -2);
				for (var i = 0; i < keys.length; i++) routeParams[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i]);
				return router[route];
			};
			for (var route in router) {
				if (route == path) return router[route];

				var matcher = new RegExp("^" + route.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "$");

				if (matcher.test(path)) {
					return path.replace(matcher, replacer);
				}
			}
		};

		// If the routes file contained a routes declaration
		// find the module to be called and extract the params.
		if (routes) {
			mod = routeByValue(routes, req.url) || routes[def];
			console.log('rbv', mod, routeParams);
		}
		// If the routes file had a single call to `m.module`
		// then it would already be stored in `mod`
		if (!mod) {
			res.send(500, 'Missing routes or single module declaration');
		}

		// Call that module, with the body of the fake DOM as its root.
		Mithril.module(mock.window.document.body, IsoModules[mod]);


		// Read the template for the page normally the `index.html` file.
		FS.read(path.join(localRoot, page)).then(function (data) {
			// Locate the placeholder for the server-side content
			var i = data.indexOf(placeholder);
			// If the placeholder is not found, return the page as-is
			if (i == -1) return void res.send(data);
			// avoid 304 - Not Modified
			res.setHeader('Last-Modified', (new Date()).toUTCString());


			//			console.log('\n\nvar cellCache = ', JSON.stringify(Mithril.$cellCache[0], function (key, value) {
			//				if (key == 'nodes') value = value.length + ' [' + value.map(function (node) { return node.nodeName || node.nodeValue;}) + ']';
			//				return value;
			//			}));
			//			var inController = function (value) {
			//				var m, mod = Mithril.$controller;
			//				for (m in mod) {
			//					if (mod[m] == value) {
			//						return m;
			//					}
			//				}
			//			};
			//
			//			console.log('\n\nvar cell = ', JSON.stringify(Mithril.$cell, function (key, value) {
			//				var m, obj;
			//				if (typeof value == 'function') {
			//
			//					for (m in Mithril) {
			//						if (Mithril[m] == value) {
			//							value = '* Mithril: ' + m;
			//						}
			//					}
			//
			//					wAttrList.forEach(function (entry) {
			//						if (entry.wrap == value) {
			//							m = inController(entry.fn);
			//							value = '* withAttr ' + entry.attr + (m ? ', controller: ' + m : '');
			//						}
			//					});
			//
			//					obj = IsoModules[mod];
			//					for (m in obj) {
			//						if (obj[m] == value) {
			//							value = '* IsoModules[' + mod + ']: ' + m;
			//						}
			//					}
			//					m = inController(value);
			//					if (m) value = '* controller: ' + m;
			//
			//					value = value.toString();
			//				}
			//				if (key == 'config' && value == Mithril.route) value = 'm.route()';
			//				return value;
			//			}));

			// Send the HTML produced server-side
			// inserted where the placeholder should have been.
			res.send(
				data.substr(0, i) +
				// send the HTML
				mock.html +
				// send code to fix the URL on the client
				(
					req.url.length > 2 && req.url.substr(0, 2) != '/?' ?
					'\n<script>window.history.replaceState(null, window.document.title, "' +
					remoteRoot + modes[routeMode] + req.url + '")</script>' :
					''
				) +
				// Send the script containing Mithril, the app, the reviver and the app.
				'\n<script src="' + path.join('/', app, script) + '" async></script>' +
				data.substr(i + placeholder.length)
			);

		});
	};
};